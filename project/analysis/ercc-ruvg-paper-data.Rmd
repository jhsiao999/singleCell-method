---
title: "RUVg: Zebra Fish data"
author: Joyce Hsiao
date: "2015-11-24"
output: 
  html_document:
    css: floating-toc.css
    toc: true
---

## Goal

Apply RUVg to the zerbra fish data set in the RUV paper.

Use RUVg from [Risso et al., 2014][Risso2014], k = 1.
It uses the ERCC spike-ins as negative control genes to correct for unwanted variation.
It uses counts as input and output.
It requires one parameter to be chosen:
`k` is the "number of factors of unwanted variation to be estimated from the data".

[Risso2014]: http://www.nature.com/nbt/journal/v32/n9/full/nbt.2931.html



## Set up

```{r, message=FALSE, warning=FALSE}
library(RUVSeq)
library(edgeR)

library(knitr)
opts_knit$set(progress = TRUE, verbose = TRUE)
opts_chunk$set(message = FALSE, warning = FALSE, eval = TRUE, 
               echo = TRUE)
```


## Prepare data

Data description: Cell pools were created from zerbrafish, mixed sex, 5 days post fertilization. Then, olfactory sensory neurons were isolated from three pairs of gallein-treated and control embryonic zebrafish cell polls. Each of the six RNA samples was enriched in poly(A)+ RNA and prepared as a cDNA library. The six libraries were sequenced in two runs.


Import read counts.

```{r}
read_files <- list.files(path = "../data/gse-53334",
                         full.names = TRUE)

reads_raw <- do.call(cbind,
    lapply(1:length(read_files), 
        function(per_file) {
            reads <- read.table( read_files[per_file],
                       header = TRUE, sep = "\t",
                       stringsAsFactors = FALSE,
                       row.names = 1)
            reads <- as.numeric(unlist(reads))
        })
    )
dim(reads_raw)
rownames(reads_raw) <- 
    rownames(read.table(read_files[1], 
                        header = TRUE, sep = "\t",
                        stringsAsFactors = FALSE,
                        row.names = 1) )
```

Remove genes with sum of zero counts across samples

```{r}
reads_raw <- reads_raw[rowSums(reads_raw) > 0, ]
head(reads_raw)
```


Make meta data matrix.

```{r}
read_files_list <- lapply(1:length(read_files),
    function(per_file) {
        strsplit(read_files[per_file], split = "_", fixed = TRUE)
    })
condition <- unlist( lapply(read_files_list, function(xx) xx[[1]][2]) )
pool <- unlist( lapply(read_files_list, function(xx) xx[[1]][3]) )
run <- unlist( lapply(read_files_list, function(xx) xx[[1]][4]) )
run <- as.numeric(gsub("[^\\d]+", "", run, perl=TRUE))

metadata <- data.frame(condition = condition,
                       pool = pool,
                       run = run,
                       sample = paste(rep(c("C", "T"), each = 6), 
                                      pool, run, sep = "."))
```


ERCC or ENSG index

```{r}
which_ercc <- grep("ERCC", rownames(reads_raw))
which_ensg <- grep("ERCC", rownames(reads_raw), invert = TRUE)
```


## library size

```{r, fig.width=8, fig.height=5}
library(matrixStats)

par(mfrow = c(1,2))
barplot(colSums(reads_raw[which_ercc, ]),
        col = c("red", "blue")[metadata$condition],
        names.arg = metadata$sample,
        cex.axis = .6)
title(main = "ERCC counts")


barplot(colSums(reads_raw[which_ensg, ]),
        col = c("red", "blue")[metadata$condition],
        names.arg = metadata$sample,
        cex.axis = .6)
title(main = "ENSG counts")
```

## PCA

```{r, fig.width=8, fig.height=5}
pca_ensg <- prcomp(t(reads_raw[which_ensg, ]),
                   retx = TRUE, scale. = TRUE, center = TRUE)
pca_ercc <- prcomp(t(reads_raw[which_ercc, ]),
                   retx = TRUE, scale. = TRUE, center = TRUE)

par(mfrow = c(1,2))
plot(x = pca_ensg$x[ ,1],
     y = pca_ensg$x[ ,2],
     xlab = "PC1", ylab = "PC2",
     pch = 16, col = c("red", "blue")[metadata$condition],
     main = "ENSG")

plot(x = pca_ercc$x[ ,1],
     y = pca_ercc$x[ ,2],
     xlab = "PC1", ylab = "PC2",
     pch = 16, col = c("red", "blue")[metadata$condition],
     main = "ERCC")
```

ERCC PC1 is highly correlatd with CPM.

```{r}
plot(x = pca_ercc$x[ ,1],
     y = colSums(reads_raw[which_ercc, ]),
     pch = "", xlim = c(-10, 10),
     ylab = "total ERCC mapped reads",
     xlab = "ERCC PC1")
text(x = pca_ercc$x[ ,1],
     y = colSums(reads_raw[which_ercc, ]),
     labels = as.character(metadata$sample),
     col = c("red", "blue")[metadata$condition])
```


ENSG PC1 is not CPM. 

```{r}
plot(x = pca_ensg$x[ ,1],
     y = colSums(reads_raw[which_ensg, ]),
     pch = "", xlim = c(-150, 200),
     ylab = "total ENSG mapped reads",
     xlab = "ENSG PC1")
text(x = pca_ensg$x[ ,1],
     y = colSums(reads_raw[which_ensg, ]),
     labels = as.character(metadata$sample),
     col = c("red", "blue")[metadata$condition])
```


## RUVg


```{r}
reads_ruv_k1 <- RUVg(as.matrix(reads_raw),
                     cIdx = which_ercc,
                     k = 1)
```

We were able to replicate Figure 5 in the paper.

```{r}
par(mfrow = c(1,2))
plotRLE(reads_raw[which_ensg, ], outline = FALSE)

plotRLE(reads_ruv_k1$normalizedCounts[which_ensg, ], outline = FALSE)
```


Let's do PCA on the normlized counts.

```{r}
ensg_normed <- reads_ruv_k1$normalizedCounts[which_ensg, ]
summary(rowSums(ensg_normed))

pca_normed <- prcomp(t(ensg_normed),
                     retx = TRUE, center = FALSE,
                     scale. = TRUE)

par(mfrow = c(2,2))
plot(x = pca_normed$x[ ,1],
     y = pca_normed$x[ ,2],
     ylab = "ENSG PC2",
     xlab = "ENSG PC1",
     pch = "")
text(x = pca_normed$x[ ,1],
     y = pca_normed$x[ ,2],
     labels = metadata$sample,
     col = c("red", "blue")[metadata$condition])


plot(x = pca_normed$x[ ,1],
     y = colSums(reads_raw[which_ensg, ]),
     pch = 16, 
     ylab = "total ENSG mapped reads",
     xlab = "ENSG RUV-normed PC1",
     col = c("red", "blue")[metadata$condition])

plot(x = pca_normed$x[ ,1],
     y = colSums(reads_raw[which_ercc, ]),
     pch = 16, 
     ylab = "total ENSG mapped reads",
     xlab = "ENSG RUV-normed PC1",
     col = c("red", "blue")[metadata$condition])
```



## Session information

```{r info}
sessionInfo()
```
