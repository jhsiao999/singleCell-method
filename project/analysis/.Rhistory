data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE)
dim(Data)
dim(data)
data[1,]
data[2,]
data[2877,]
data[1,]
data[2,]
data[3,]
colnames(data)
grep("cdc",colnames(data))
cdc_data <- data[,grep("cdc",colnames(data))];
dim(cdc_data)
colnames(cdc_data)
cdc_data[,1]
which(is.na(cdc_data))
which(is.na(cdc_data[1,]))
cdc_data[1,]
cdc_data[2,]
which(is.na(cdc_data[2,]))
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data_mod <- apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = FALSE));
cdc_data_mod[2,]
cdc_data[2,]
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = FALSE)));
cdc_data_mod[2,]
cdc_data[2,]
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cdc_data_mod[2,]
dim(cdc_data_mod)
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
cycle_data <- t(cdc_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_cdc_pooled.rda")
library(qtlcharts)
library(CountClust)
library(parallel)
library(cellcycleR)
library(data.table)
library(binhf)
library(vioplot)
library(limma)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_cdc_pooled.rda")
out <- get(load(file="../rdas/cell_order_yeast_cdc_pooled.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 3);
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
cell_order_full
colnames(cdc_data)[order(cell_order_full)]
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_cdc15.rda")
cycle_data_norm[1,]
is.na(cycle_data_norm)
which(is.na(cycle_data_norm))
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
dim(cycle_data)
colSums(cycle_data)
which(is.na(colSums(cycle_data)))
cycle_data[,54]
rowSums(cycle_data)
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
which(is.na(colSums(cdc_data_mod)))
cdc_data_mod[1:5,1:5]
which(is.na(rowSums(cdc_data_mod)))
cdc_data_mod[54,]
dim(cdc_data_mod)
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
rowSums(is.na(m)) > (dim(cdc_data)[2] - 4)
rowSums(is.na(cdc_data)) > (dim(cdc_data)[2] - 4)
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) > (dim(cdc_data)[2] - 4),];
dim(cdc_data)
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
rm(list=ls())
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
dim(cdc_data)
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_cdc15.rda")
out <- get(load(file="../rdas/cell_order_yeast_cdc15.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 3);
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
cell_order_full
colnames(cdc_data)[cell_order_full]
colnames(cdc_data)[order(cell_order_full)]
colnames(cdc_data)
iplotCurves(t(cycle_data_norm[,top_genes]))
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc28",colnames(data))];
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
colnames(cdc_data)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_cdc28.rda")
out <- get(load(file="../rdas/cell_order_yeast_cdc28.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
iplotCurves(t(cycle_data_norm[,top_genes]))
colnames(cdc_data)[order(cell_order_full)]
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
colnames(data)
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
elu_data <- data[,grep("elu",colnames(data))];
colnames(elu_data)
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
elu_data <- data[,grep("elu",colnames(data))];
elu_data <- cdc_data[rowSums(is.na(elu_data)) < (dim(elu_data)[2] - 4),];
elu_data_mod <- t(apply(elu_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(elu_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_elu.rda")
which(is.na(cycle_data_norm))
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
elu_data <- data[,grep("elu",colnames(data))];
elu_data <- elu_data[rowSums(is.na(elu_data)) < (dim(elu_data)[2] - 4),];
elu_data_mod <- t(apply(elu_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(elu_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_elu.rda")
out <- get(load(file="../rdas/cell_order_yeast_elu.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[,top_genes]))
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
colnames(elu_data)[order(cell_order_full)]
new_cell_order <- shift(order(cell_order_full),6,dir="right")
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
new_cell_order <- shift(order(cell_order_full),7,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
print(colnames(data)[new_cell_order])
print(colnames(elu_data)[new_cell_order])
temp <- shift(order(cell_order_full),6,dir="right")
print(colnames(elu_data)[temp])
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
alpha_data <- data[,grep("alpha",colnames(data))];
dim(alpha_data)
rm(list=ls()
)
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
alpha_data <- data[,grep("alpha",colnames(data))];
alpha_data <- alpha_data[rowSums(is.na(alpha_data)) < (dim(alpha_data)[2] - 4),];
alpha_data_mod <- t(apply(alpha_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(alpha_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
alpha_data <- data[,grep("alpha",colnames(data))];
alpha_data <- alpha_data[rowSums(is.na(alpha_data)) < (dim(alpha_data)[2] - 4),];
alpha_data_mod <- t(apply(alpha_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(alpha_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
out <- cell_ordering_class(cycle_data_norm, celltime_levels = 100, num_iter=100, save_path="../rdas/cell_order_yeast_alpha.rda")
out <- get(load(file="../rdas/cell_order_yeast_alpha.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[,top_genes]))
new_cell_order <- shift(order(cell_order_full),6,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
new_cell_order <- shift(order(cell_order_full),1,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
new_cell_order <- shift(order(cell_order_full),-1,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
new_cell_order <- shift(order(cell_order_full),-3,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
temp <- shift(order(cell_order_full),-3,dir="right")
print(colnames(elu_data)[temp])
print(colnames(alpha_data)[temp])
temp <- shift(order(cell_order_full),6,dir="right")
print(colnames(alpha_data)[temp])
new_cell_order <- shift(order(cell_order_full),6,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
out <- get(load(file="../rdas/cell_order_yeast_cdc28.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[,top_genes]))
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc28",colnames(data))];
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
out <- get(load(file="../rdas/cell_order_yeast_cdc28.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[,top_genes]))
temp <- shift(order(cell_order_full),6,dir="right")
print(colnames(cdc_data)[temp])
temp <- shift(order(cell_order_full),-7,dir="right")
print(colnames(cdc_data)[temp])
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
out <- get(load(file="../rdas/cell_order_yeast_cdc15.rda"));
cell_order_full <- cell_ordering_full(out$signal_intensity, dim(cycle_data_norm)[2])
amp_genes <- out$amp;
sd_genes <- out$sigma;
phi_genes <- out$phi;
plot(density(phi_genes), col="red", main="Density plot of the phases")
plot(density(amp_genes[-which.max(amp_genes)]), col="red", main="Density plot of the amplitudes")
plot(density(sd_genes[-which.max(sd_genes)]), col="red", main="Density plot of the non-signal sd")
ESS <- amp_genes^2; RSS <- sd_genes^2
SNR <- ESS/RSS;
plot(SNR, col="red", pch=20, lwd=1)
top_genes <- which(SNR > 10);
iplotCurves(t(cycle_data_norm[,top_genes]))
iplotCurves(t(cycle_data_norm[order(cell_order_full),top_genes]))
temp <- shift(order(cell_order_full),-7,dir="right")
print(colnames(cdc_data)[temp])
temp <- shift(order(cell_order_full),2,dir="right")
print(colnames(cdc_data)[temp])
new_cell_order <- shift(order(cell_order_full),2,dir="right")
iplotCurves(t(cycle_data_norm[new_cell_order,top_genes]))
temp <- shift(order(cell_order_full),2,dir="right")
print(colnames(cdc_data)[temp])
