metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation;
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata)], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata)], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
order(elevation_metadata)
plot(pmd1$v[,1], type="l")
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
par(mar=c(12,2,2,1))
barplot(t(pos1[order(elevation_metadata)]), col=2:3)
barplot(t(neg1[order(elevation_metadata)]), col=2:3, add=TRUE)
barplot(t(pos1[order(elevation_metadata)]), col=2:3)
barplot(t(neg1[order(elevation_metadata)]), col=2:3, add=TRUE)
pos1
pmd1 <- PMD(padded_data, type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation;
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1[order(elevation_metadata),]), col=2:3)
barplot(t(neg1[order(elevation_metadata),]), col=2:3, add=TRUE)
dim(padded_data)
padded_counts <- t(apply(new_counts_sorted, 1, function(x)
{
y=x;
length(y)<-512;
y[is.na(y)]<-0
return(y)
}))
padded_data <- log(padded_counts+0.5)
dim(padded_data)
pmd1 <- PMD(padded_data, type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation;
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
pos2
dim(pos2)
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation;
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
source('ntmfit.R')
system.time(out1 <- NTMfit(padded_data[-(1:3),], K=2));
K <- 2;
barplot(t(out1$omega_out[order(elevation_metadata),]),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
source('/Users/kushal/Documents/Matthew Stephens Project/Non Technical/wavelets/ntmfit.R')
system.time(out1 <- NTMfit(padded_data[-(1:3),], K=2));
K <- 2;
barplot(t(out1$omega_out[order(elevation_metadata),]),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
plot(out1$alpha_out[1,], type="l")
plot(out1$alpha_out[2,], type="l")
wave_data <- t(apply(padded_data[-(1:3),], 1, function(x)
{
out <- wd(x, filter.number = 3, family = "DaubExPhase")
return(out$D)
}));
K <- 2;
system.time(out2 <- NTMfit(wave_data, K=2));
barplot(t(out2$omega_out[order(elevation_metadata),]),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
plot(out2$alpha_out[1,], type="l")
plot(out2$alpha_out[2,], type="l")
order(elevation_metadata)
elevation_metadata[order(elevation_metadata)]
barplot(t(out2$omega_out[order(elevation_metadata),]),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
plot(out2$alpha_out[1,], type="l")
plot(out2$alpha_out[2,], type="l")
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation;
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
source('../R/ntmfit.R')
data=read.csv("../external_data/Himalayan_grid_matrix.csv",header=TRUE);
getwd()
setwd('/Users/kushal/Documents/Matthew Stephens Project/Non Technical/wavelets/src/')
data=read.csv("../external_data/Himalayan_grid_matrix.csv",header=TRUE);
source('../R/ntmfit.R')
elevation_metadata
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
metadata
padded_data[1:10,]
rownames(metadata)
metadata[,1]
length(metadata[,1])
elevation_metadata=metadata$Elevation[ match(rownames(padded_data[-(1:3),]),metadata[,1])];
elevation_metadata
east_west_dir = metadata$WorE;
east_west_dir
east_west_dir = metadata$WorE[match(rownames(padded_data[-(1:3),]),metadata[,1])];
east_west_dir
new_counts[1,]
padded_counts[1,]
out2$alpha_out[1,]
W <- GenW(n=512, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% t(out2$alpha_out);
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
rm(list=ls())
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- t(cdc_data_mod);
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,2,function(x)  return (x-mean(x))/sd(x))
celltime_levels <- 100;
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
cycle_data_norm[1:5,1:5]
colnames(cdc_data)
rownames(cycle_data_norm)
colnames(cdc_data)
dim(cycle_data_norm)
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- cdc_data_mod);
dim(cycle_data)
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc15",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- cdc_data_mod;
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,1,function(x)  return (x-mean(x))/sd(x))
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
padded_data <- t(apply(cycle_data_norm, 1, function(x)
{
y=x;
length(y)<-32;
y[is.na(y)]<-0
return(y)
}))
dim(padded_data)
padded_data <- t(apply(cycle_data_norm, 2, function(x)
{
y=x;
length(y)<-32;
y[is.na(y)]<-0
return(y)
}))
dim(padded_data)
library(PMA)
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation[match(rownames(padded_data[-(1:3),]),metadata[,1])];
east_west_dir = metadata$WorE[match(rownames(padded_data[-(1:3),]),metadata[,1])];
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
library(PMA)
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
library(PMA)
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
library(PMA)
pmd1 <- PMD(padded_data[-(1:3),], type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
library(PMA)
pmd1 <- PMD(padded_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
source('../R/ntmfit.R')
system.time(out1 <- NTMfit(padded_data, K=2));
getwd()
setwd('/Users/kushal/Documents/Matthew Stephens Project/Non Technical/wavelets/src/')
source('../R/ntmfit.R')
system.time(out1 <- NTMfit(padded_data, K=2));
barplot(t(out1$omega_out),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
K <- 2;
barplot(t(out1$omega_out),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
plot(out1$alpha_out[1,])
plot(out1$alpha_out[1,], type="l")
plot(out1$alpha_out[2,], type="l")
library(wavethresh)
wave_data <- t(apply(padded_data, 1, function(x)
{
out <- wd(x, filter.number = 3, family = "DaubExPhase")
return(out$D)
}));
dim(wave_data)
library(PMA)
pmd1 <- PMD(wave_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
W <- GenW(n=32, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% t(pmd1$v);
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
idwt <- W[,-1] %*% pmd1$v;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
K <- 2;
system.time(out2 <- NTMfit(wave_data, K=2));
barplot(t(out2$omega_out[order(elevation_metadata),]),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
barplot(t(out2$omega_out),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
W <- GenW(n=32, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% out2$alpha_out;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
idwt <- W[,-1] %*% t(out2$alpha_out);
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
setwd("/Users/kushal/Documents/singleCell-method/project/analysis/")
data <- read.table("../data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("cdc28",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- cdc_data_mod;
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,1,function(x)  return (x-mean(x))/sd(x))
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
padded_data <- t(apply(cycle_data_norm, 2, function(x)
{
y=x;
length(y)<-32;
y[is.na(y)]<-0
return(y)
}))
library(PMA)
pmd1 <- PMD(padded_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
source('../R/ntmfit.R')
system.time(out1 <- NTMfit(padded_data, K=2));
K <- 2;
barplot(t(out1$omega_out),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
plot(out1$alpha_out[1,], type="l")
plot(out1$alpha_out[2,], type="l")
library(wavethresh)
wave_data <- t(apply(padded_data, 1, function(x)
{
out <- wd(x, filter.number = 3, family = "DaubExPhase")
return(out$D)
}));
library(PMA)
pmd1 <- PMD(wave_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
W <- GenW(n=32, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% pmd1$v;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
K <- 2;
system.time(out2 <- NTMfit(wave_data, K=2));
barplot(t(out2$omega_out),col=2:(K+1),axisnames=F,space=0,border=NA,main="",las=1,ylim=c(0,1),cex.axis=1.5,cex.main=1.4)
title(main=paste("Structure Plot topic proportions,k=",K))
W <- GenW(n=32, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% t(out2$alpha_out);
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
library(PMA)
pmd1 <- PMD(wave_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
W <- GenW(n=32, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% pmd1$v;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
